#include "myutils.h"
#include "scop40bench.h"
#include <map>

/***
-calibrate4
Unsupervised per-chain linear fit of log-scale bined TS
 
Input is generated by

reseek \
  -calibrate3 c:/Users/Computer/source/repos/rcedgar/reseek_scop40/reseek_db/scop40_family.cal \
  -log calibrate3.log \
  -calib_output z:/int/reseek_calibrate/out/calibrate3.tsv \
  -calib_output2 z:/int/reseek_calibrate/out/top_tpfp.tsv
***/

void LinearFit(const vector<float> &xs, const vector<float> &ys,
  float &m, float &b);

/***
less -S calibrate3.tsv
TS      -0.0938 -0.0812 -0.0688 -0.0562 -0.0437 -0.0312 -0.0187 -0.00625        0.00625 0.0188  0.0>
d1vkya_/e.53.1.1        11205   11205   11204   11197   11181   11134   11041   10745   10055   779>
d3nfka_/b.36.1.1        11205   11205   11205   11205   11205   11205   11202   11191   11158   109>
***/

static void GetDownslope(const vector<uint> &Bins,
  uint MinPct, uint MaxUpSteps,
  uint &LoBin, uint &HiBin)
	{
	LoBin = 0;
	HiBin = UINT_MAX;
	const uint BinCount = SIZE(Bins);
	uint MaxCount = Bins[0];
	for (uint Bin = 1; Bin < BinCount; ++Bin)
		{
		uint n = Bins[Bin];
		if (n > MaxCount)
			{
			MaxCount = n;
			LoBin = Bin;
			}
		}

	uint MinCount = (MaxCount*MinPct)/100 + 1;
	uint SmallestCountSoFar = Bins[LoBin];
	uint UpStepCount = 0;
	for (uint Bin = LoBin + 1; Bin < BinCount; ++Bin)
		{
		uint n = Bins[Bin];
		if (n < MinCount)
			break;
		if (n > Bins[Bin-1])
			{
			++UpStepCount;
			if (UpStepCount > MaxUpSteps)
				break;
			}
		else
			UpStepCount = 0;
		if (n < SmallestCountSoFar)
			{
			SmallestCountSoFar = n;
			HiBin = Bin;
			}
		}
	}

// Per-chain unsupervised log-linear fit
void cmd_calibrate4()
	{
	const string &FN1 = g_Arg1;
	const uint MinPct = 1;
	const uint MaxUpSteps = 1;

	FILE *fOut = CreateStdioFile(opt_output);

	string Line;
	vector<string> Fields;

	FILE *f = OpenStdioFile(FN1);
	string HdrLine;
	bool Ok = ReadLineStdioFile(f, HdrLine);
	asserta(Ok);
	vector<string> HdrFields;
	Split(HdrLine, HdrFields, '\t');
	uint n = SIZE(HdrFields);
	asserta(n > 0 && HdrFields[0] == "TS");
	uint BinCount = n - 1;
	asserta(BinCount > 3);
	while (ReadLineStdioFile(f, Line))
		{
		Split(Line, Fields, '\t');
		asserta(SIZE(Fields) == BinCount + 1);
		const string &Dom = Fields[0];
		vector<uint> Bins;
		for (uint Bin = 0; Bin < BinCount; ++Bin)
			{
			uint n = StrToUint(Fields[Bin+1]);
			Bins.push_back(n);
			}

		uint LoBin, HiBin;
		GetDownslope(Bins, MinPct, MaxUpSteps, LoBin, HiBin);
		if (fOut != 0)
			{
			fprintf(fOut, "%s", Dom.c_str());
			if (LoBin == UINT_MAX)
				fprintf(fOut, "\t.");
			else
				fprintf(fOut, "\t%u", LoBin);
			if (HiBin == UINT_MAX)
				fprintf(fOut, "\t.");
			else
				fprintf(fOut, "\t%u", HiBin);
			for (uint Bin = 0; Bin < BinCount; ++Bin)
				fprintf(fOut, "\t%u", Bins[Bin]);
			fprintf(fOut, "\n");

			Log("%s", Dom.c_str());
			if (LoBin == UINT_MAX || HiBin == UINT_MAX)
				Log("  **FAILED\n");
			else
				{
				Log(" %u-%u", LoBin, HiBin);
				for (uint Bin = LoBin; Bin <= HiBin; ++Bin)
					Log("  %u", Bins[Bin]);
				Log("\n");
				}
			}
		}
	CloseStdioFile(f);
	CloseStdioFile(fOut);
	}
