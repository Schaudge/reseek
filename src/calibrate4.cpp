#include "myutils.h"
#include "scop40bench.h"
#include <map>

/***
-calibrate4
 
Input is generated by -calibrate3 -calib_output2

reseek \
  -calibrate3 c:/Users/Computer/source/repos/rcedgar/reseek_scop40/reseek_db/scop40_family.cal \
  -log calibrate3.log \
  -calib_output2 z:/int/reseek_calibrate/out/calibrate3_tpfp.tsv
***/

/***
less -S calibrate3_tpfp.tsv

TS      TP0.02  TP0.06  TP0.1   TP0.14  TP0.18  TP0.22  TP0.26  TP0.3   TP0.34  TP0.38  TP0.42  TP0.46  TP0.5   TP0.54 >
d3nfka_/b.36.1  0       0       0       0       1       0       0       2       3       0       3       7       6      >
d1tdja3/d.58.18 0       0       3       6       9       1       0       1       0       0       0       0       0      >
d2gtlm1/b.61.7  0       0       0       0       0       0       0       0       0       0       0       0       0      >
d1t6ca2/c.55.1  0       5       11      14      21      7       1       0       0       0       0       0       0      >
***/

static uint GetModalBin(const vector<uint> &Bins)
	{
	const uint N = SIZE(Bins);
	asserta(N > 0);
	uint MB = 0;
	uint mn = Bins[0];
	for (uint Bin = 1; Bin < N; ++Bin)
		{
		uint n = Bins[Bin];
		if (n > mn)
			{
			mn = n;
			MB = Bin;
			}
		}
	return MB;
	}

static void GetBinToAlpha(const vector<uint> &Bins, vector<uint> &BinToAlpha)
	{
	const uint BinCount = SIZE(Bins);
	BinToAlpha.clear();
	BinToAlpha.resize(BinCount);
	uint N = 0;
	for (uint Bin = 0; Bin < BinCount; ++Bin)
		N += Bins[Bin];

	uint Accum = 0;
	for (uint i = 0; i < BinCount; ++i)
		{
		uint Bin = BinCount - i - 1;
		Accum += Bins[Bin];
		uint Alpha = uint((Accum*10)/(N+1));
		asserta(Alpha >= 0 && Alpha < 10);
		BinToAlpha[Bin] = Alpha;
		}
	}

void cmd_calibrate4()
	{
	const string &FN1 = g_Arg1;

	FILE *fOut = CreateStdioFile(opt_output);

	string Line;
	vector<string> Fields;

	FILE *f = OpenStdioFile(FN1);
	string HdrLine;
	bool Ok = ReadLineStdioFile(f, HdrLine);
	asserta(Ok);
	vector<string> HdrFields;
	Split(HdrLine, HdrFields, '\t');
	uint n = SIZE(HdrFields);
	asserta(n%2 == 1);
	asserta(n > 0 && HdrFields[0] == "TS");
	uint BinCount = (n - 1)/2;
	asserta(BinCount > 3);
	uint NT = 0;
	uint NF = 0;

// [TP/FP]CountVec[alpha][m]
//	alpha is 0..9 = 10xfraction of hits with TS>=TS_alpha
//	m is modal bin
	vector<vector<uint> > FPCountVec(10);
	vector<vector<uint> > TPCountVec(10);
	for (uint Alpha = 0; Alpha < 10; ++Alpha)
		{
		FPCountVec[Alpha].resize(BinCount);
		TPCountVec[Alpha].resize(BinCount);
		}

	vector<uint> AlphaCounts(10);
	vector<uint> MBCounts(BinCount);
	uint DomCount = 0;
	while (ReadLineStdioFile(f, Line))
		{
		Split(Line, Fields, '\t');
		asserta(SIZE(Fields) == 2*BinCount + 1);
		const string &Dom = Fields[0];
		vector<uint> Bins;
		vector<uint> TP_Bins;
		vector<uint> FP_Bins;
		for (uint Bin = 0; Bin < BinCount; ++Bin)
			{
			uint nt = StrToUint(Fields[1+Bin]);
			uint nf = StrToUint(Fields[1+BinCount + Bin]);
			NT += nt;
			NF += nf;
			Bins.push_back(nt + nf);
			TP_Bins.push_back(nt);
			FP_Bins.push_back(nf);
			}
		uint MB = GetModalBin(Bins);
		DomCount += 1;
		MBCounts[MB] += 1;
		vector<uint> BinToAlpha;
		GetBinToAlpha(Bins, BinToAlpha);
		asserta(SIZE(BinToAlpha) == BinCount);
		for (uint Bin = 0; Bin < BinCount; ++Bin)
			{
			uint Alpha = BinToAlpha[Bin];
			asserta(Alpha < 10);
			AlphaCounts[Alpha] += Bins[Bin];
			TPCountVec[Alpha][MB] += TP_Bins[Bin];
			FPCountVec[Alpha][MB] += FP_Bins[Bin];
			}
		}
	CloseStdioFile(f);
	CloseStdioFile(fOut);

	vector<vector<double> > PTMx(10);
	vector<vector<double> > PMx(10);
	double SumP = 0;
	double SumPt = 0;
	for (uint Alpha = 0; Alpha < 10; ++Alpha)
		{
		PMx[Alpha].resize(BinCount);
		PTMx[Alpha].resize(BinCount);
		for (uint Bin = 0; Bin < BinCount; ++Bin)
			{
			uint nt = TPCountVec[Alpha][Bin];
			uint nf = FPCountVec[Alpha][Bin];
			double P = double(nt + nf)/(NT + NF);
			double Pt = double(nt)/NT;
			SumP += P;
			SumPt += Pt;
			PMx[Alpha][Bin] = P;
			PTMx[Alpha][Bin] = Pt;
			}
		}
	double PT = double(NT)/(NT + NF);
	Log("SumP = %.4f, %.4f, PT %.4f\n", SumP, SumPt, PT);

	for (uint Alpha = 0; Alpha < 10; ++Alpha)
		Log("Alpha [%u]   %u\n", Alpha, AlphaCounts[Alpha]);

	Log("\n");
	for (uint MB = 0; MB < 10; ++MB)
		Log("   MB [%u]   %u\n", MB, MBCounts[MB]);

	Log("\n");
	Log("TPCountsVec\n");
	for (uint Alpha = 0; Alpha < 10; ++Alpha)
		{
		Log("Alpha [%u] ", Alpha);
		for (uint Bin = 0; Bin < BinCount; ++Bin)
			{
			uint n = TPCountVec[Alpha][Bin];
			if (n == 0)
				Log(" %7.7s", ".");
			else
				Log(" %7u", n);
			}
		Log("\n");
		}

	Log("\n");
	Log("FPCountsVec\n");
	for (uint Alpha = 0; Alpha < 10; ++Alpha)
		{
		Log("Alpha [%u] ", Alpha);
		for (uint Bin = 0; Bin < BinCount; ++Bin)
			{
			uint n = FPCountVec[Alpha][Bin];
			if (n == 0)
				Log(" %7.7s", ".");
			else
				Log(" %7u", n);
			}
		Log("\n");
		}
	Log("\n");
	Log("P(alpha and m)\n");
	for (uint Alpha = 0; Alpha < 10; ++Alpha)
		{
		Log("Alpha [%u] ", Alpha);
		for (uint Bin = 0; Bin < BinCount; ++Bin)
			{
			double P = PMx[Alpha][Bin];
			Log(" %9.3g", P);
			}
		Log("\n");
		}

	Log("\n");
	Log("P(alpha and m | T)\n");
	for (uint Alpha = 0; Alpha < 10; ++Alpha)
		{
		Log("Alpha [%u] ", Alpha);
		for (uint Bin = 0; Bin < BinCount; ++Bin)
			{
			double P = PTMx[Alpha][Bin];
			Log(" %9.3g", P);
			}
		Log("\n");
		}

	Log("\n");
	Log("P(T | alpha and m)\n");
	for (uint Alpha = 0; Alpha < 10; ++Alpha)
		{
		Log("Alpha [%u] ", Alpha);
		for (uint Bin = 0; Bin < BinCount; ++Bin)
			{
			double Pa = PTMx[Alpha][Bin];
			double P = PMx[Alpha][Bin];
			if (P == 0)
				P = 0.001;
			double Pb = Pa*PT/P;
			Log(" %9.3g", Pb);
			}
		Log("\n");
		}
	}
